package ghidrassist;

import ghidra.program.model.listing.*;
import ghidra.program.model.pcode.*;
import ghidra.program.model.address.Address;
import ghidra.app.decompiler.*;
import ghidra.util.task.TaskMonitor;

import java.util.*;

public class VulnerabilityScanner {

    public static class Vulnerability {
        public String type;
        public String severity; // "CRITICAL", "HIGH", "MEDIUM", "LOW"
        public String description;
        public String location;
        public String recommendation;

        public Vulnerability(String type, String severity, String description,
                           String location, String recommendation) {
            this.type = type;
            this.severity = severity;
            this.description = description;
            this.location = location;
            this.recommendation = recommendation;
        }

        @Override
        public String toString() {
            return String.format("[%s] %s at %s: %s",
                               severity, type, location, description);
        }
    }

    private final Program program;
    private final DecompInterface decompiler;

    public VulnerabilityScanner(Program program) {
        this.program = program;
        this.decompiler = new DecompInterface();
        this.decompiler.openProgram(program);
    }

    public List<Vulnerability> scanFunction(Function function) {
        List<Vulnerability> vulnerabilities = new ArrayList<>();

        try {
            // 1. Buffer Overflow Detection
            vulnerabilities.addAll(detectBufferOverflows(function));

            // 2. Integer Overflow Detection
            vulnerabilities.addAll(detectIntegerOverflows(function));

            // 3. Format String Vulnerabilities
            vulnerabilities.addAll(detectFormatStrings(function));

            // 4. Null Pointer Dereference
            vulnerabilities.addAll(detectNullPointerDereferences(function));

            // 5. Use of Dangerous Functions
            vulnerabilities.addAll(detectDangerousFunctions(function));

        } catch (Exception e) {
            // Log error but continue
            System.err.println("Error scanning function " + function.getName() + ": " + e.getMessage());
        }

        return vulnerabilities;
    }

    private List<Vulnerability> detectBufferOverflows(Function function) {
        List<Vulnerability> vulns = new ArrayList<>();

        // Look for strcpy, strcat without bounds checking
        InstructionIterator instructions = program.getListing().getInstructions(
            function.getBody(), true
        );

        while (instructions.hasNext()) {
            Instruction instr = instructions.next();
            String mnemonic = instr.getMnemonicString();

            // Check for CALL instructions
            if (mnemonic.equals("CALL")) {
                String target = getCallTargetName(instr);

                if (target != null && isDangerousStringFunction(target)) {
                    vulns.add(new Vulnerability(
                        "Buffer Overflow",
                        "HIGH",
                        "Potentially unsafe call to " + target + " without bounds checking",
                        instr.getAddress().toString(),
                        "Replace with safer alternatives (strncpy, strncat, snprintf)"
                    ));
                }
            }
        }

        return vulns;
    }

    private boolean isDangerousStringFunction(String functionName) {
        String[] dangerous = {"strcpy", "strcat", "sprintf", "gets", "scanf", "vsprintf"};
        for (String func : dangerous) {
            if (functionName.toLowerCase().contains(func.toLowerCase())) {
                return true;
            }
        }
        return false;
    }

    private List<Vulnerability> detectIntegerOverflows(Function function) {
        List<Vulnerability> vulns = new ArrayList<>();

        try {
            DecompileResults results = decompiler.decompileFunction(function, 30, TaskMonitor.DUMMY);

            if (!results.decompileCompleted()) {
                return vulns;
            }

            HighFunction highFunction = results.getHighFunction();
            if (highFunction == null) {
                return vulns;
            }

            Iterator<PcodeOpAST> ops = highFunction.getPcodeOps();

            while (ops.hasNext()) {
                PcodeOpAST op = ops.next();

                // Check for unchecked arithmetic
                if (op.getOpcode() == PcodeOp.INT_ADD ||
                    op.getOpcode() == PcodeOp.INT_MULT ||
                    op.getOpcode() == PcodeOp.INT_LEFT) {

                    // Check if result could be used in size calculation
                    if (couldBeUsedInSizeCalculation(op)) {
                        vulns.add(new Vulnerability(
                            "Integer Overflow",
                            "MEDIUM",
                            "Arithmetic operation may overflow when used in size calculation",
                            op.getSeqnum().getTarget().toString(),
                            "Add overflow checking before size calculations"
                        ));
                    }
                }
            }
        } catch (Exception e) {
            // Decompilation failed, skip integer overflow detection
        }

        return vulns;
    }

    private List<Vulnerability> detectFormatStrings(Function function) {
        List<Vulnerability> vulns = new ArrayList<>();

        InstructionIterator instructions = program.getListing().getInstructions(
            function.getBody(), true
        );

        while (instructions.hasNext()) {
            Instruction instr = instructions.next();

            if (instr.getMnemonicString().equals("CALL")) {
                String target = getCallTargetName(instr);

                if (target != null && isFormatFunction(target)) {
                    vulns.add(new Vulnerability(
                        "Format String",
                        "CRITICAL",
                        "Potential format string vulnerability in " + target,
                        instr.getAddress().toString(),
                        "Use format specifiers with constant format strings"
                    ));
                }
            }
        }

        return vulns;
    }

    private boolean isFormatFunction(String functionName) {
        String[] formatFuncs = {"printf", "fprintf", "sprintf", "snprintf",
                               "vprintf", "vfprintf", "vsprintf"};
        for (String func : formatFuncs) {
            if (functionName.toLowerCase().contains(func.toLowerCase())) {
                return true;
            }
        }
        return false;
    }

    private List<Vulnerability> detectNullPointerDereferences(Function function) {
        List<Vulnerability> vulns = new ArrayList<>();

        try {
            DecompileResults results = decompiler.decompileFunction(function, 30, TaskMonitor.DUMMY);

            if (!results.decompileCompleted()) {
                return vulns;
            }

            HighFunction highFunction = results.getHighFunction();
            if (highFunction == null) {
                return vulns;
            }

            Iterator<PcodeOpAST> ops = highFunction.getPcodeOps();

            while (ops.hasNext()) {
                PcodeOpAST op = ops.next();

                // Check for LOAD/STORE operations that could dereference null
                if (op.getOpcode() == PcodeOp.LOAD || op.getOpcode() == PcodeOp.STORE) {
                    // Simplified check - in production would need data flow analysis
                    vulns.add(new Vulnerability(
                        "Potential Null Pointer Dereference",
                        "LOW",
                        "Pointer dereference without null check",
                        op.getSeqnum().getTarget().toString(),
                        "Add null pointer checks before dereferencing"
                    ));
                }
            }
        } catch (Exception e) {
            // Decompilation failed
        }

        return vulns;
    }

    private List<Vulnerability> detectDangerousFunctions(Function function) {
        List<Vulnerability> vulns = new ArrayList<>();

        String[] dangerousFuncs = {
            "system", "exec", "popen", "eval",
            "malloc", "free", "realloc", "alloca"
        };

        InstructionIterator instructions = program.getListing().getInstructions(
            function.getBody(), true
        );

        while (instructions.hasNext()) {
            Instruction instr = instructions.next();

            if (instr.getMnemonicString().equals("CALL")) {
                String target = getCallTargetName(instr);

                if (target != null) {
                    for (String dangerousFunc : dangerousFuncs) {
                        if (target.toLowerCase().contains(dangerousFunc.toLowerCase())) {
                            String severity = getSeverityForDangerousFunction(dangerousFunc);
                            vulns.add(new Vulnerability(
                                "Dangerous Function Usage",
                                severity,
                                "Use of potentially dangerous function: " + target,
                                instr.getAddress().toString(),
                                "Review usage and consider safer alternatives"
                            ));
                        }
                    }
                }
            }
        }

        return vulns;
    }

    private String getSeverityForDangerousFunction(String funcName) {
        switch (funcName.toLowerCase()) {
            case "system":
            case "exec":
            case "popen":
            case "eval":
                return "CRITICAL";
            case "malloc":
            case "free":
            case "realloc":
                return "LOW";
            default:
                return "MEDIUM";
        }
    }

    private boolean couldBeUsedInSizeCalculation(PcodeOpAST op) {
        // Simplified heuristic - check if result is used in subsequent CALL or alloc
        // In production, would need full data flow analysis
        return true; // Conservative approach
    }

    private String getCallTargetName(Instruction instr) {
        try {
            // Get the first operand (call target)
            if (instr.getNumOperands() > 0) {
                Object[] opObjects = instr.getOpObjects(0);
                if (opObjects != null && opObjects.length > 0) {
                    if (opObjects[0] instanceof Address) {
                        Address addr = (Address) opObjects[0];
                        Function calledFunc = program.getFunctionManager().getFunctionAt(addr);
                        if (calledFunc != null) {
                            return calledFunc.getName();
                        }
                    }
                }
            }
        } catch (Exception e) {
            // Ignore
        }
        return null;
    }

    public void dispose() {
        if (decompiler != null) {
            decompiler.dispose();
        }
    }
}
