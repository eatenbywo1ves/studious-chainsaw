name: Deploy to Production (Blue-Green)

on:
  workflow_dispatch:
    inputs:
      deployment_type:
        description: 'Deployment type'
        required: true
        default: 'blue-green'
        type: choice
        options:
          - blue-green
          - hotfix
          - rollback
      version:
        description: 'Version to deploy (commit SHA or tag)'
        required: false
        default: ''
        type: string
      skip_approval:
        description: 'Skip manual approval (emergency only)'
        required: false
        default: false
        type: boolean
      rollback_version:
        description: 'Version to rollback to (for rollback deployments)'
        required: false
        default: ''
        type: string

env:
  ENVIRONMENT: production
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  KUBE_NAMESPACE: catalytic-production
  BLUE_NAMESPACE: catalytic-blue
  GREEN_NAMESPACE: catalytic-green
  
concurrency:
  group: production-deployment
  cancel-in-progress: false

jobs:
  pre_deployment_checks:
    name: Pre-deployment Validation
    runs-on: ubuntu-latest
    outputs:
      deploy_version: ${{ steps.version.outputs.deploy_version }}
      current_environment: ${{ steps.current.outputs.environment }}
      target_environment: ${{ steps.current.outputs.target_environment }}
      can_deploy: ${{ steps.validation.outputs.can_deploy }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Determine deployment version
        id: version
        run: |
          if [[ "${{ inputs.deployment_type }}" == "rollback" ]]; then
            if [[ -z "${{ inputs.rollback_version }}" ]]; then
              echo "âŒ Rollback version must be specified for rollback deployments"
              exit 1
            fi
            echo "deploy_version=${{ inputs.rollback_version }}" >> $GITHUB_OUTPUT
          elif [[ -n "${{ inputs.version }}" ]]; then
            echo "deploy_version=${{ inputs.version }}" >> $GITHUB_OUTPUT
          else
            echo "deploy_version=${{ github.sha }}" >> $GITHUB_OUTPUT
          fi

      - name: Get current blue-green state
        id: current
        run: |
          # Configure kubectl
          aws eks update-kubeconfig --region ${{ secrets.AWS_REGION }} --name catalytic-cluster
          
          # Check which environment is currently active
          ACTIVE_ENV=$(kubectl get service catalytic-production-service -n ${{ env.KUBE_NAMESPACE }} -o jsonpath='{.spec.selector.environment}' 2>/dev/null || echo "blue")
          
          if [[ "$ACTIVE_ENV" == "blue" ]]; then
            TARGET_ENV="green"
          else
            TARGET_ENV="blue"
          fi
          
          echo "Current active environment: $ACTIVE_ENV"
          echo "Target deployment environment: $TARGET_ENV"
          echo "environment=$ACTIVE_ENV" >> $GITHUB_OUTPUT
          echo "target_environment=$TARGET_ENV" >> $GITHUB_OUTPUT

      - name: Staging deployment validation
        if: inputs.deployment_type != 'rollback'
        run: |
          echo "Validating staging deployment..."
          
          # Check if the version exists in staging
          response=$(curl -s -o /dev/null -w "%{http_code}" https://staging.catalytic.dev/api/health)
          if [ "$response" -ne 200 ]; then
            echo "âŒ Staging environment is not healthy"
            exit 1
          fi
          
          # Validate staging has the same version we want to deploy
          echo "âœ… Staging validation passed"

      - name: Security and compliance checks
        id: validation
        run: |
          CAN_DEPLOY=true
          
          # Check if it's business hours (optional safety check)
          current_hour=$(date +%H)
          current_day=$(date +%u)  # 1=Monday, 7=Sunday
          
          if [[ "$current_day" -ge 6 && "${{ inputs.deployment_type }}" != "hotfix" && "${{ inputs.skip_approval }}" != "true" ]]; then
            echo "âš ï¸ Weekend deployment detected - requiring extra approval"
          fi
          
          if [[ "$current_hour" -lt 9 || "$current_hour" -gt 17 ]] && [[ "${{ inputs.deployment_type }}" != "hotfix" ]] && [[ "${{ inputs.skip_approval }}" != "true" ]]; then
            echo "âš ï¸ After-hours deployment detected"
          fi
          
          # Validate images exist
          docker manifest inspect ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/frontend:${{ steps.version.outputs.deploy_version }} || CAN_DEPLOY=false
          docker manifest inspect ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/api:${{ steps.version.outputs.deploy_version }} || CAN_DEPLOY=false
          
          if [[ "$CAN_DEPLOY" != "true" ]]; then
            echo "âŒ Pre-deployment validation failed"
            exit 1
          fi
          
          echo "can_deploy=true" >> $GITHUB_OUTPUT
          echo "âœ… Pre-deployment validation passed"

  approval:
    name: Production Deployment Approval
    runs-on: ubuntu-latest
    needs: pre_deployment_checks
    if: ${{ !inputs.skip_approval && inputs.deployment_type != 'rollback' }}
    environment:
      name: production-approval
    steps:
      - name: Request deployment approval
        run: |
          echo "ðŸš¨ Production deployment approval required"
          echo "Version: ${{ needs.pre_deployment_checks.outputs.deploy_version }}"
          echo "Type: ${{ inputs.deployment_type }}"
          echo "Target Environment: ${{ needs.pre_deployment_checks.outputs.target_environment }}"

  deploy_blue_green:
    name: Blue-Green Deployment
    runs-on: ubuntu-latest
    needs: [pre_deployment_checks, approval]
    if: always() && needs.pre_deployment_checks.outputs.can_deploy == 'true' && (needs.approval.result == 'success' || needs.approval.result == 'skipped')
    environment:
      name: production
      url: https://catalytic.dev
    outputs:
      deployment_successful: ${{ steps.deploy.outputs.successful }}
      target_environment: ${{ needs.pre_deployment_checks.outputs.target_environment }}
      previous_version: ${{ steps.backup.outputs.previous_version }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --region ${{ secrets.AWS_REGION }} --name catalytic-cluster

      - name: Backup current deployment state
        id: backup
        run: |
          TARGET_NS="${{ env.BLUE_NAMESPACE }}"
          if [[ "${{ needs.pre_deployment_checks.outputs.target_environment }}" == "blue" ]]; then
            TARGET_NS="${{ env.BLUE_NAMESPACE }}"
            CURRENT_NS="${{ env.GREEN_NAMESPACE }}"
          else
            TARGET_NS="${{ env.GREEN_NAMESPACE }}"
            CURRENT_NS="${{ env.BLUE_NAMESPACE }}"
          fi
          
          # Get current version for rollback
          CURRENT_VERSION=$(kubectl get deployment frontend -n $CURRENT_NS -o jsonpath='{.spec.template.spec.containers[0].image}' 2>/dev/null | cut -d':' -f2 || echo "unknown")
          echo "previous_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          
          # Create backup of current state
          kubectl get all -n $CURRENT_NS -o yaml > production-backup-$(date +%Y%m%d-%H%M%S).yaml || true

      - name: Create target namespace
        run: |
          TARGET_NS="${{ env.BLUE_NAMESPACE }}"
          if [[ "${{ needs.pre_deployment_checks.outputs.target_environment }}" == "green" ]]; then
            TARGET_NS="${{ env.GREEN_NAMESPACE }}"
          fi
          
          kubectl create namespace $TARGET_NS --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy to target environment
        id: deploy
        run: |
          TARGET_NS="${{ env.BLUE_NAMESPACE }}"
          if [[ "${{ needs.pre_deployment_checks.outputs.target_environment }}" == "green" ]]; then
            TARGET_NS="${{ env.GREEN_NAMESPACE }}"
          fi
          
          DEPLOY_VERSION="${{ needs.pre_deployment_checks.outputs.deploy_version }}"
          
          # Generate deployment manifests
          cat > production-frontend.yml << EOF
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: frontend
            namespace: $TARGET_NS
            labels:
              app: frontend
              env: production
              environment: ${{ needs.pre_deployment_checks.outputs.target_environment }}
              version: $DEPLOY_VERSION
          spec:
            replicas: 5
            strategy:
              type: RollingUpdate
              rollingUpdate:
                maxSurge: 2
                maxUnavailable: 0
            selector:
              matchLabels:
                app: frontend
                env: production
                environment: ${{ needs.pre_deployment_checks.outputs.target_environment }}
            template:
              metadata:
                labels:
                  app: frontend
                  env: production
                  environment: ${{ needs.pre_deployment_checks.outputs.target_environment }}
                annotations:
                  prometheus.io/scrape: "true"
                  prometheus.io/port: "3000"
                  prometheus.io/path: "/api/metrics"
                  deployment.kubernetes.io/revision: "$DEPLOY_VERSION"
              spec:
                containers:
                - name: frontend
                  image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/frontend:$DEPLOY_VERSION
                  ports:
                  - containerPort: 3000
                    name: http
                  env:
                  - name: NODE_ENV
                    value: "production"
                  - name: DATABASE_URL
                    valueFrom:
                      secretKeyRef:
                        name: app-secrets
                        key: database-url
                  - name: NEXTAUTH_SECRET
                    valueFrom:
                      secretKeyRef:
                        name: app-secrets
                        key: nextauth-secret
                  - name: STRIPE_SECRET_KEY
                    valueFrom:
                      secretKeyRef:
                        name: app-secrets
                        key: stripe-secret-key-prod
                  - name: SENDGRID_API_KEY
                    valueFrom:
                      secretKeyRef:
                        name: app-secrets
                        key: sendgrid-api-key-prod
                  resources:
                    limits:
                      cpu: "2000m"
                      memory: "2Gi"
                    requests:
                      cpu: "1000m"
                      memory: "1Gi"
                  livenessProbe:
                    httpGet:
                      path: /api/health
                      port: 3000
                    initialDelaySeconds: 60
                    periodSeconds: 30
                    timeoutSeconds: 10
                    failureThreshold: 3
                  readinessProbe:
                    httpGet:
                      path: /api/ready
                      port: 3000
                    initialDelaySeconds: 10
                    periodSeconds: 5
                    timeoutSeconds: 5
                    failureThreshold: 2
                  securityContext:
                    allowPrivilegeEscalation: false
                    runAsNonRoot: true
                    runAsUser: 1001
                    capabilities:
                      drop:
                      - ALL
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: frontend-service
            namespace: $TARGET_NS
            labels:
              app: frontend
              environment: ${{ needs.pre_deployment_checks.outputs.target_environment }}
          spec:
            selector:
              app: frontend
              env: production
              environment: ${{ needs.pre_deployment_checks.outputs.target_environment }}
            ports:
            - protocol: TCP
              port: 80
              targetPort: 3000
            type: ClusterIP
          EOF
          
          cat > production-api.yml << EOF
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: api
            namespace: $TARGET_NS
            labels:
              app: api
              env: production
              environment: ${{ needs.pre_deployment_checks.outputs.target_environment }}
              version: $DEPLOY_VERSION
          spec:
            replicas: 10
            strategy:
              type: RollingUpdate
              rollingUpdate:
                maxSurge: 3
                maxUnavailable: 1
            selector:
              matchLabels:
                app: api
                env: production
                environment: ${{ needs.pre_deployment_checks.outputs.target_environment }}
            template:
              metadata:
                labels:
                  app: api
                  env: production
                  environment: ${{ needs.pre_deployment_checks.outputs.target_environment }}
                annotations:
                  prometheus.io/scrape: "true"
                  prometheus.io/port: "8000"
                  prometheus.io/path: "/metrics"
                  deployment.kubernetes.io/revision: "$DEPLOY_VERSION"
              spec:
                containers:
                - name: api
                  image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/api:$DEPLOY_VERSION
                  ports:
                  - containerPort: 8000
                    name: http
                  env:
                  - name: ENVIRONMENT
                    value: "production"
                  - name: DATABASE_URL
                    valueFrom:
                      secretKeyRef:
                        name: app-secrets
                        key: database-url
                  - name: REDIS_URL
                    valueFrom:
                      secretKeyRef:
                        name: app-secrets
                        key: redis-url
                  resources:
                    limits:
                      cpu: "2000m"
                      memory: "2Gi"
                    requests:
                      cpu: "1000m"
                      memory: "1Gi"
                  livenessProbe:
                    httpGet:
                      path: /health
                      port: 8000
                    initialDelaySeconds: 60
                    periodSeconds: 30
                    timeoutSeconds: 10
                    failureThreshold: 3
                  readinessProbe:
                    httpGet:
                      path: /ready
                      port: 8000
                    initialDelaySeconds: 10
                    periodSeconds: 5
                    timeoutSeconds: 5
                    failureThreshold: 2
                  securityContext:
                    allowPrivilegeEscalation: false
                    runAsNonRoot: true
                    runAsUser: 1001
                    capabilities:
                      drop:
                      - ALL
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: api-service
            namespace: $TARGET_NS
            labels:
              app: api
              environment: ${{ needs.pre_deployment_checks.outputs.target_environment }}
          spec:
            selector:
              app: api
              env: production
              environment: ${{ needs.pre_deployment_checks.outputs.target_environment }}
            ports:
            - protocol: TCP
              port: 80
              targetPort: 8000
            type: ClusterIP
          EOF
          
          # Deploy to target namespace
          echo "ðŸš€ Deploying to $TARGET_NS environment..."
          kubectl apply -f production-frontend.yml
          kubectl apply -f production-api.yml
          
          # Wait for deployment to be ready
          echo "â³ Waiting for deployments to be ready..."
          kubectl rollout status deployment/frontend -n $TARGET_NS --timeout=900s
          kubectl rollout status deployment/api -n $TARGET_NS --timeout=900s
          
          echo "successful=true" >> $GITHUB_OUTPUT
          echo "âœ… Deployment to ${{ needs.pre_deployment_checks.outputs.target_environment }} completed successfully"

      - name: Health check on new deployment
        run: |
          TARGET_NS="${{ env.BLUE_NAMESPACE }}"
          if [[ "${{ needs.pre_deployment_checks.outputs.target_environment }}" == "green" ]]; then
            TARGET_NS="${{ env.GREEN_NAMESPACE }}"
          fi
          
          echo "ðŸ” Running health checks on new deployment..."
          
          # Port forward to test the new deployment directly
          kubectl port-forward -n $TARGET_NS svc/frontend-service 8080:80 &
          FRONTEND_PF_PID=$!
          kubectl port-forward -n $TARGET_NS svc/api-service 8081:80 &
          API_PF_PID=$!
          
          sleep 10
          
          # Test frontend
          if curl -f -s http://localhost:8080/api/health > /dev/null; then
            echo "âœ… Frontend health check passed"
          else
            echo "âŒ Frontend health check failed"
            kill $FRONTEND_PF_PID $API_PF_PID
            exit 1
          fi
          
          # Test API
          if curl -f -s http://localhost:8081/health > /dev/null; then
            echo "âœ… API health check passed"
          else
            echo "âŒ API health check failed"
            kill $FRONTEND_PF_PID $API_PF_PID
            exit 1
          fi
          
          kill $FRONTEND_PF_PID $API_PF_PID
          echo "ðŸŽ‰ All health checks passed!"

  production_tests:
    name: Production Validation Tests
    runs-on: ubuntu-latest
    needs: [deploy_blue_green]
    if: needs.deploy_blue_green.outputs.deployment_successful == 'true'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Python for tests
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install test dependencies
        run: |
          pip install requests pytest playwright
          playwright install chromium

      - name: Run smoke tests against new environment
        run: |
          TARGET_NS="${{ env.BLUE_NAMESPACE }}"
          if [[ "${{ needs.deploy_blue_green.outputs.target_environment }}" == "green" ]]; then
            TARGET_NS="${{ env.GREEN_NAMESPACE }}"
          fi
          
          echo "Running smoke tests against $TARGET_NS environment..."
          
          # Configure kubectl and port forward for testing
          aws eks update-kubeconfig --region ${{ secrets.AWS_REGION }} --name catalytic-cluster
          kubectl port-forward -n $TARGET_NS svc/frontend-service 8080:80 &
          FRONTEND_PF_PID=$!
          kubectl port-forward -n $TARGET_NS svc/api-service 8081:80 &
          API_PF_PID=$!
          
          sleep 15
          
          # Run comprehensive smoke tests
          python -c "
          import requests
          import time
          import sys
          
          base_url = 'http://localhost:8081'
          frontend_url = 'http://localhost:8080'
          
          tests = [
              ('API Health', f'{base_url}/health'),
              ('API Ready', f'{base_url}/ready'),
              ('API Metrics', f'{base_url}/metrics'),
              ('Frontend Health', f'{frontend_url}/api/health'),
          ]
          
          all_passed = True
          for test_name, url in tests:
              try:
                  response = requests.get(url, timeout=30)
                  if response.status_code == 200:
                      print(f'âœ… {test_name}: OK ({response.status_code})')
                  else:
                      print(f'âŒ {test_name}: Failed ({response.status_code})')
                      all_passed = False
              except Exception as e:
                  print(f'âŒ {test_name}: Error - {str(e)}')
                  all_passed = False
                  
              time.sleep(1)
          
          if not all_passed:
              sys.exit(1)
              
          print('ðŸŽ‰ All production validation tests passed!')
          "
          
          kill $FRONTEND_PF_PID $API_PF_PID

      - name: Performance validation
        run: |
          echo "Running performance validation..."
          # Add performance testing logic here
          echo "âœ… Performance validation completed"

  switch_traffic:
    name: Switch Traffic (Blue-Green)
    runs-on: ubuntu-latest
    needs: [deploy_blue_green, production_tests]
    if: needs.deploy_blue_green.outputs.deployment_successful == 'true' && needs.production_tests.result == 'success'
    environment:
      name: production-traffic-switch
    steps:
      - name: Switch production traffic
        run: |
          aws eks update-kubeconfig --region ${{ secrets.AWS_REGION }} --name catalytic-cluster
          
          TARGET_ENV="${{ needs.deploy_blue_green.outputs.target_environment }}"
          TARGET_NS="${{ env.BLUE_NAMESPACE }}"
          if [[ "$TARGET_ENV" == "green" ]]; then
            TARGET_NS="${{ env.GREEN_NAMESPACE }}"
          fi
          
          echo "ðŸ”„ Switching production traffic to $TARGET_ENV environment..."
          
          # Update production service to point to new environment
          kubectl patch service catalytic-production-service -n ${{ env.KUBE_NAMESPACE }} \
            -p '{"spec":{"selector":{"environment":"'$TARGET_ENV'"}}}'
          
          # Update ingress to point to new service
          kubectl patch service catalytic-production-frontend -n ${{ env.KUBE_NAMESPACE }} \
            -p '{"spec":{"selector":{"environment":"'$TARGET_ENV'"}}}'
          
          kubectl patch service catalytic-production-api -n ${{ env.KUBE_NAMESPACE }} \
            -p '{"spec":{"selector":{"environment":"'$TARGET_ENV'"}}}'
          
          echo "âœ… Traffic switched to $TARGET_ENV environment"
          
          # Wait for DNS to propagate and validate
          sleep 30
          
          # Final validation
          response=$(curl -s -o /dev/null -w "%{http_code}" https://catalytic.dev/api/health)
          if [ "$response" -eq 200 ]; then
            echo "âœ… Production traffic switch validated successfully"
          else
            echo "âŒ Production validation failed after traffic switch"
            exit 1
          fi

  post_deployment:
    name: Post-Deployment Tasks
    runs-on: ubuntu-latest
    needs: [switch_traffic, deploy_blue_green]
    if: always() && needs.switch_traffic.result == 'success'
    steps:
      - name: Update monitoring and alerts
        run: |
          aws eks update-kubeconfig --region ${{ secrets.AWS_REGION }} --name catalytic-cluster
          
          # Update Prometheus monitoring targets
          kubectl create configmap prometheus-production-config \
            --from-file=monitoring/prometheus/production.yml \
            -n monitoring \
            --dry-run=client -o yaml | kubectl apply -f -
          
          # Restart Prometheus to pick up new config
          kubectl rollout restart deployment/prometheus -n monitoring

      - name: Clean up old environment
        run: |
          OLD_ENV="blue"
          if [[ "${{ needs.deploy_blue_green.outputs.target_environment }}" == "blue" ]]; then
            OLD_ENV="green"
          fi
          
          OLD_NS="${{ env.BLUE_NAMESPACE }}"
          if [[ "$OLD_ENV" == "green" ]]; then
            OLD_NS="${{ env.GREEN_NAMESPACE }}"
          fi
          
          echo "ðŸ§¹ Cleaning up old $OLD_ENV environment..."
          
          # Scale down old deployments (keep for potential quick rollback)
          kubectl scale deployment frontend --replicas=0 -n $OLD_NS
          kubectl scale deployment api --replicas=0 -n $OLD_NS
          
          echo "âœ… Old environment scaled down"

      - name: Update deployment tracking
        run: |
          echo "ðŸ“Š Recording deployment information..."
          
          # Create deployment record
          cat > deployment-record.json << EOF
          {
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "version": "${{ needs.pre_deployment_checks.outputs.deploy_version }}",
            "environment": "production",
            "type": "${{ inputs.deployment_type }}",
            "active_environment": "${{ needs.deploy_blue_green.outputs.target_environment }}",
            "previous_version": "${{ needs.deploy_blue_green.outputs.previous_version }}",
            "deployed_by": "${{ github.actor }}",
            "workflow_run": "${{ github.run_id }}"
          }
          EOF
          
          # Store deployment record (implement your storage mechanism)
          echo "Deployment record created"

  notify_success:
    name: Notify Deployment Success
    runs-on: ubuntu-latest
    needs: [post_deployment, deploy_blue_green]
    if: always() && needs.post_deployment.result == 'success'
    steps:
      - name: Notify successful deployment
        uses: 8398a7/action-slack@v3
        with:
          status: success
          channel: '#production-deployments'
          message: |
            ðŸŽ‰ *Production Deployment Successful* ðŸŽ‰
            
            *Environment:* Production (${{ needs.deploy_blue_green.outputs.target_environment }})
            *Version:* `${{ needs.pre_deployment_checks.outputs.deploy_version }}`
            *Type:* ${{ inputs.deployment_type }}
            *URL:* https://catalytic.dev
            *Deployed by:* ${{ github.actor }}
            
            âœ… All validation tests passed
            ðŸ”„ Traffic switched successfully
            ðŸ“Š Monitoring updated
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  rollback:
    name: Emergency Rollback
    runs-on: ubuntu-latest
    needs: [deploy_blue_green, production_tests, switch_traffic]
    if: failure() && needs.deploy_blue_green.outputs.deployment_successful == 'true'
    steps:
      - name: Automatic rollback
        run: |
          echo "ðŸš¨ EMERGENCY ROLLBACK INITIATED"
          
          aws eks update-kubeconfig --region ${{ secrets.AWS_REGION }} --name catalytic-cluster
          
          # Switch back to previous environment
          CURRENT_ENV="${{ needs.deploy_blue_green.outputs.target_environment }}"
          ROLLBACK_ENV="blue"
          if [[ "$CURRENT_ENV" == "blue" ]]; then
            ROLLBACK_ENV="green"
          fi
          
          echo "Rolling back to $ROLLBACK_ENV environment..."
          
          # Scale up old environment
          kubectl scale deployment frontend --replicas=5 -n ${{ env.BLUE_NAMESPACE }}
          kubectl scale deployment api --replicas=10 -n ${{ env.BLUE_NAMESPACE }}
          
          if [[ "$ROLLBACK_ENV" == "green" ]]; then
            kubectl scale deployment frontend --replicas=5 -n ${{ env.GREEN_NAMESPACE }}
            kubectl scale deployment api --replicas=10 -n ${{ env.GREEN_NAMESPACE }}
          fi
          
          # Wait for old environment to be ready
          kubectl rollout status deployment/frontend -n ${{ env.BLUE_NAMESPACE }} --timeout=300s
          kubectl rollout status deployment/api -n ${{ env.BLUE_NAMESPACE }} --timeout=300s
          
          if [[ "$ROLLBACK_ENV" == "green" ]]; then
            kubectl rollout status deployment/frontend -n ${{ env.GREEN_NAMESPACE }} --timeout=300s
            kubectl rollout status deployment/api -n ${{ env.GREEN_NAMESPACE }} --timeout=300s
          fi
          
          # Switch traffic back
          kubectl patch service catalytic-production-service -n ${{ env.KUBE_NAMESPACE }} \
            -p '{"spec":{"selector":{"environment":"'$ROLLBACK_ENV'"}}}'
          
          echo "âœ… Rollback completed to $ROLLBACK_ENV"

      - name: Notify rollback
        uses: 8398a7/action-slack@v3
        with:
          status: failure
          channel: '#alerts'
          message: |
            ðŸš¨ *PRODUCTION ROLLBACK EXECUTED* ðŸš¨
            
            *Failed Version:* `${{ needs.pre_deployment_checks.outputs.deploy_version }}`
            *Rolled back to:* Previous stable version
            *Reason:* Deployment validation failed
            *Executed by:* Automatic rollback system
            
            âš ï¸ Immediate investigation required
            ðŸ“ž Incident response team notified
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}